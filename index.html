<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Name Combination Finder</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f7f7f7; }
    h2 { margin-bottom: 10px; }
    input, button, select {
      padding: 8px; margin: 5px; font-size: 16px;
    }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 8px;
      text-align: left;
      font-size: 15px;
    }
    #result, #closestMatch {
      margin-top: 15px;
      padding: 10px;
      background: #fff;
      border: 1px solid #ccc;
    }
    .scrollable-table {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ccc;
      background: white;
    }
    #loading {
      color: #666;
      font-style: italic;
    }
    .match-header {
      margin-top: 20px;
      font-weight: bold;
    }
  </style>
</head>
<body>

  <h2>Name Combination Finder</h2>

  <label for="target">Target Value:</label>
  <input type="number" id="target" />
  
  <label for="maxItems">Items in Combination:</label>
  <select id="maxItems">
    <option value="1">1</option>
    <option value="2" selected>2</option>
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5">5</option>
    <option value="6">6</option>
    <option value="7">7</option>
    <option value="8">8</option>
  </select>

  <button onclick="findCombinations()">Find</button>
  <div id="loading"></div>

  <div class="scrollable-table">
    <table id="dataTable">
      <thead>
        <tr><th>Name</th><th>Value</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="result" class="match-header"></div>
  <div id="closestMatch"></div>

  <script>
    let nameValues = [];

    // Load data from external data.txt
    async function loadData() {
      const response = await fetch('data.txt');
      const text = await response.text();
      const lines = text.split('\n');
      for (let line of lines) {
        const [name, value] = line.trim().split(',');
        if (name && value && !isNaN(value)) {
          nameValues.push({ name, value: parseInt(value) });
        }
      }
      renderTable();
    }

    function renderTable() {
      const tbody = document.querySelector("#dataTable tbody");
      tbody.innerHTML = "";
      nameValues.forEach(({ name, value }) => {
        const row = document.createElement("tr");
        row.innerHTML = `<td>${name}</td><td>${value}</td>`;
        tbody.appendChild(row);
      });
    }

    function findCombinations() {
      const target = parseInt(document.getElementById("target").value);
      const maxItems = parseInt(document.getElementById("maxItems").value);
      const resultDiv = document.getElementById("result");
      const closestDiv = document.getElementById("closestMatch");
      const loadingDiv = document.getElementById("loading");

      resultDiv.innerHTML = "";
      closestDiv.innerHTML = "";
      loadingDiv.innerText = "Searching... Please wait.";

      setTimeout(() => {
        let validValues = nameValues.filter(item => item.value <= target);
        validValues.sort((a, b) => b.value - a.value); // Start from high

        let results = [];
        let closest = { diff: Infinity, combo: null };

        function search(current, start, sum) {
          if (current.length > maxItems || sum > target) return;
          if (sum === target) {
            results.push([...current]);
            return;
          }

          if (sum < target && (target - sum) < closest.diff) {
            closest = { diff: target - sum, combo: [...current] };
          }

          for (let i = start; i < validValues.length; i++) {
            current.push(validValues[i]);
            search(current, i + 1, sum + validValues[i].value);
            current.pop();
          }
        }

        search([], 0, 0);

        loadingDiv.innerText = "";

        if (results.length > 0) {
          resultDiv.innerHTML = `<strong>✅ Top ${Math.min(10, results.length)} Result(s):</strong><br>`;
          results.slice(0, 10).forEach(combo => {
            const names = combo.map(c => `${c.name} (${c.value})`).join(' + ');
            resultDiv.innerHTML += `• ${names} = ${combo.reduce((s, c) => s + c.value, 0)}<br>`;
          });
        } else {
          resultDiv.innerHTML = "❌ No combinations found.";
        }

        if (closest.combo) {
          const names = closest.combo.map(c => `${c.name} (${c.value})`).join(' + ');
          const sum = closest.combo.reduce((a, b) => a + b.value, 0);
          closestDiv.innerHTML = `<strong>Closest Match:</strong><br>• ${names} = ${sum}`;
        }
      }, 50); // Yield for UI responsiveness
    }

    window.onload = loadData;
  </script>
</body>
</html>
