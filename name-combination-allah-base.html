<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Name Combination Finder</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { font-size: 24px; }
    input, button, select { padding: 6px; margin: 4px 0; }
    #table-container { max-height: 300px; overflow-y: scroll; border: 1px solid #ccc; margin-bottom: 10px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { padding: 6px; border: 1px solid #ccc; text-align: left; }
    #results { margin-top: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>

<h1>Name Combination Tool</h1>

<label>Target Value:</label>
<input type="number" id="target" placeholder="Enter target number" />

<label>Max Combination Items:</label>
<select id="maxItems">
  <option value="1">1</option>
  <option value="2">2</option>
  <option value="3">3</option>
  <option value="4" selected>4</option>
  <option value="5">5</option>
  <option value="6">6</option>
  <option value="7">7</option>
  <option value="8">8</option>
</select>

<br>
<button onclick="findCombinations()">Find</button>

<div id="results"></div>

<h3>Name-Value Table</h3>
<div id="table-container">
  <table id="dataTable">
    <thead>
      <tr><th>Name</th><th>Value</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
let data = [];

async function loadData() {
  try {
    const res = await fetch("data.txt");
    const text = await res.text();
    const lines = text.trim().split("\n");
    for (const line of lines) {
      const [name, value] = line.split(",");
      if (name && !isNaN(parseInt(value))) {
        data.push({ name: name.trim(), value: parseInt(value) });
      }
    }
    populateTable();
  } catch (err) {
    alert("Failed to load data.txt");
    console.error(err);
  }
}

function populateTable() {
  const tbody = document.querySelector("#dataTable tbody");
  tbody.innerHTML = "";
  for (const entry of data) {
    const row = document.createElement("tr");
    const nameCell = document.createElement("td");
    const valueCell = document.createElement("td");
    nameCell.textContent = entry.name;
    valueCell.textContent = entry.value;
    row.appendChild(nameCell);
    row.appendChild(valueCell);
    tbody.appendChild(row);
  }
}

function findCombinations() {
  const target = parseInt(document.getElementById("target").value);
  const maxItems = parseInt(document.getElementById("maxItems").value);
  const resultsDiv = document.getElementById("results");
  resultsDiv.innerHTML = "⏳ Searching combinations...";

  if (isNaN(target) || target <= 0) {
    resultsDiv.innerHTML = "❌ Please enter a valid target number.";
    return;
  }

  // Slight pause to update UI
  setTimeout(() => {
    const combinations = [];

    const filteredData = data.filter(d => d.value <= target);
    const allah = data.find(d => d.name === "अल्लाहु");

    function dfs(start, path, sum, depth, withAllah) {
      if (sum === target && path.length <= maxItems) {
        combinations.push([...path]);
        return;
      }
      if (sum > target || path.length >= maxItems) return;

      for (let i = start; i < filteredData.length; i++) {
        const item = filteredData[i];
        if (withAllah && item.name === "अल्लाहु") continue; // prevent duplicates of "अल्लाहु"
        path.push(item);
        dfs(i + 1, path, sum + item.value, depth + 1, withAllah);
        path.pop();
      }
    }

    // First: combinations starting with "अल्लाहु"
    if (allah && allah.value <= target) {
      dfs(0, [allah], allah.value, 1, true);
    }

    // Then: all combinations not starting with "अल्लाहु"
    dfs(0, [], 0, 0, false);

    if (combinations.length === 0) {
      // Try closest match if nothing found
      let bestMatch = null;
      let bestSum = 0;

      function findClosest(start, path, sum) {
        if (sum > bestSum && sum < target && path.length <= maxItems) {
          bestSum = sum;
          bestMatch = [...path];
        }
        if (sum >= target || path.length >= maxItems) return;

        for (let i = start; i < filteredData.length; i++) {
          path.push(filteredData[i]);
          findClosest(i + 1, path, sum + filteredData[i].value);
          path.pop();
        }
      }

      findClosest(0, [], 0);

      if (bestMatch) {
        resultsDiv.innerHTML = `❌ No exact match found.\n✅ Closest match (Total ${bestSum}):\n` +
          bestMatch.map(e => `${e.name} (${e.value})`).join(" + ");
      } else {
        resultsDiv.innerHTML = "❌ No combinations found.";
      }

    } else {
      resultsDiv.innerHTML = `✅ ${combinations.length} combinations found:\n\n` +
        combinations.map(c =>
          c.map(e => `${e.name} (${e.value})`).join(" + ") +
          ` = ${c.reduce((sum, e) => sum + e.value, 0)}`
        ).join("\n\n");
    }
  }, 100);
}

loadData();
</script>

</body>
</html>
